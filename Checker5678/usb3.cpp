///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);
// Local procedures 
void DrawIndica (HTuple hv_x1, HTuple hv_y1, HTuple hv_x2, HTuple hv_y2, HTuple hv_phi, 
    HTuple hv_margin, HTuple hv_value, HTuple hv_windowhandle, HTuple hv_dir);
void DoubleCircle2 (HObject ho_imagesrc, HObject ho_regionsrc, HObject ho_regionref, 
    HTuple hv_deviation_value1, HTuple hv_deviation_value2, HTuple hv_deviation_value3, 
    HTuple hv_factor, HTuple hv_half_margin, HTuple hv_WindowHandle, HTuple hv_thr, 
    HTuple hv_sigma, HTuple *hv_isError, HTuple *hv_ErrorCode, HTuple *hv_length, 
    HTuple *hv_width, HTuple *hv_angle, HTuple *hv_center_x, HTuple *hv_center_y, 
    HTuple *hv_dis_rr, HTuple *hv_up_margin, HTuple *hv_down_margin);
void SingleCircle (HObject ho_imagesrc, HObject ho_regionsrc, HObject ho_regionref, 
    HTuple hv_deviation_value1, HTuple hv_deviation_value2, HTuple hv_factor, HTuple hv_WindowHandle, 
    HTuple *hv_length, HTuple *hv_center_x, HTuple *hv_center_y, HTuple *hv_isError, 
    HTuple *hv_ErrorCode);

// Procedures 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
  HTuple  hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1;
  HTuple  hv_C1, hv_FactorRow, hv_FactorColumn, hv_UseShadow;
  HTuple  hv_ShadowColor, hv_Exception, hv_Width, hv_Index;
  HTuple  hv_Ascent, hv_Descent, hv_W, hv_H, hv_FrameHeight;
  HTuple  hv_FrameWidth, hv_R2, hv_C2, hv_DrawMode, hv_CurrentColor;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow (same as if no second value is given)
  //       otherwise -> use given string as color string for the shadow color
  //
  //Prepare window
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_Color==HTuple()))
  {
    hv_Color = "";
  }
  //
  hv_String = ((""+hv_String)+"").TupleSplit("\n");
  //
  //Estimate extentions of text depending on font size.
  GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //Transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //Display text box depending on text size
  hv_UseShadow = 1;
  hv_ShadowColor = "gray";
  if (0 != (HTuple(hv_Box[0])==HTuple("true")))
  {
    hv_Box[0] = "#fce9d4";
    hv_ShadowColor = "#f28d26";
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("true")))
    {
      //Use default ShadowColor set above
    }
    else if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      hv_UseShadow = 0;
    }
    else
    {
      hv_ShadowColor = ((const HTuple&)hv_Box)[1];
      //Valid color?
      try
      {
        SetColor(hv_WindowHandle, HTuple(hv_Box[1]));
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
        throw HalconCpp::HException(hv_Exception);
      }
    }
  }
  if (0 != (HTuple(hv_Box[0])!=HTuple("false")))
  {
    //Valid color?
    try
    {
      SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
      throw HalconCpp::HException(hv_Exception);
    }
    //Calculate box extents
    hv_String = (" "+hv_String)+" ";
    hv_Width = HTuple();
    {
    HTuple end_val93 = (hv_String.TupleLength())-1;
    HTuple step_val93 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val93, step_val93); hv_Index += step_val93)
    {
      GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, 
          &hv_Descent, &hv_W, &hv_H);
      hv_Width = hv_Width.TupleConcat(hv_W);
    }
    }
    hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
    hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
    hv_R2 = hv_R1+hv_FrameHeight;
    hv_C2 = hv_C1+hv_FrameWidth;
    //Display rectangles
    GetDraw(hv_WindowHandle, &hv_DrawMode);
    SetDraw(hv_WindowHandle, "fill");
    //Set shadow color
    SetColor(hv_WindowHandle, hv_ShadowColor);
    if (0 != hv_UseShadow)
    {
      DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, hv_C2+1);
    }
    //Set box color
    SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
    SetDraw(hv_WindowHandle, hv_DrawMode);
  }
  //Write text.
  {
  HTuple end_val115 = (hv_String.TupleLength())-1;
  HTuple step_val115 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val115, step_val115); hv_Index += step_val115)
  {
    hv_CurrentColor = ((const HTuple&)hv_Color)[hv_Index%(hv_Color.TupleLength())];
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).TupleAnd(hv_CurrentColor!=HTuple("auto"))))
    {
      SetColor(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    SetTposition(hv_WindowHandle, hv_Row, hv_C1);
    WriteString(hv_WindowHandle, HTuple(hv_String[hv_Index]));
  }
  }
  //Reset changed window settings
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
{

  // Local iconic variables
  HObject  ho_TempArrow;

  // Local control variables
  HTuple  hv_Length, hv_ZeroLengthIndices, hv_DR;
  HTuple  hv_DC, hv_HalfHeadWidth, hv_RowP1, hv_ColP1, hv_RowP2;
  HTuple  hv_ColP2, hv_Index;

  //This procedure generates arrow shaped XLD contours,
  //pointing from (Row1, Column1) to (Row2, Column2).
  //If starting and end point are identical, a contour consisting
  //of a single point is returned.
  //
  //input parameteres:
  //Row1, Column1: Coordinates of the arrows' starting points
  //Row2, Column2: Coordinates of the arrows' end points
  //HeadLength, HeadWidth: Size of the arrow heads in pixels
  //
  //output parameter:
  //Arrow: The resulting XLD contour
  //
  //The input tuples Row1, Column1, Row2, and Column2 have to be of
  //the same length.
  //HeadLength and HeadWidth either have to be of the same length as
  //Row1, Column1, Row2, and Column2 or have to be a single element.
  //If one of the above restrictions is violated, an error will occur.
  //
  //
  //Init
  GenEmptyObj(&(*ho_Arrow));
  //
  //Calculate the arrow length
  DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, &hv_Length);
  //
  //Mark arrows with identical start and end point
  //(set Length to -1 to avoid division-by-zero exception)
  hv_ZeroLengthIndices = hv_Length.TupleFind(0);
  if (0 != (hv_ZeroLengthIndices!=-1))
  {
    hv_Length[hv_ZeroLengthIndices] = -1;
  }
  //
  //Calculate auxiliary variables.
  hv_DR = (1.0*(hv_Row2-hv_Row1))/hv_Length;
  hv_DC = (1.0*(hv_Column2-hv_Column1))/hv_Length;
  hv_HalfHeadWidth = hv_HeadWidth/2.0;
  //
  //Calculate end points of the arrow head.
  hv_RowP1 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))+(hv_HalfHeadWidth*hv_DC);
  hv_ColP1 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))-(hv_HalfHeadWidth*hv_DR);
  hv_RowP2 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))-(hv_HalfHeadWidth*hv_DC);
  hv_ColP2 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))+(hv_HalfHeadWidth*hv_DR);
  //
  //Finally create output XLD contour for each input point pair
  {
  HTuple end_val45 = (hv_Length.TupleLength())-1;
  HTuple step_val45 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val45, step_val45); hv_Index += step_val45)
  {
    if (0 != (HTuple(hv_Length[hv_Index])==-1))
    {
      //Create_ single points for arrows with identical start and end point
      GenContourPolygonXld(&ho_TempArrow, HTuple(hv_Row1[hv_Index]), HTuple(hv_Column1[hv_Index]));
    }
    else
    {
      //Create arrow contour
      GenContourPolygonXld(&ho_TempArrow, ((((HTuple(hv_Row1[hv_Index]).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP1[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP2[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index])), 
          ((((HTuple(hv_Column1[hv_Index]).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP1[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP2[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index])));
    }
    ConcatObj((*ho_Arrow), ho_TempArrow, &(*ho_Arrow));
  }
  }
  return;
}

// Local procedures 
void DrawIndica (HTuple hv_x1, HTuple hv_y1, HTuple hv_x2, HTuple hv_y2, HTuple hv_phi, 
    HTuple hv_margin, HTuple hv_value, HTuple hv_windowhandle, HTuple hv_dir)
{

  // Local iconic variables
  HObject  ho_Cross1, ho_Cross2, ho_Cross3, ho_Cross4;
  HObject  ho_RegionLines, ho_RegionLines1, ho_RegionLines0;
  HObject  ho_Arrow, ho_Arrow2;

  // Local control variables
  HTuple  hv_HomMat2DIdentity, hv_p, hv_HomMat2DRotate2;
  HTuple  hv_Qx1, hv_Qy1, hv_Qx2, hv_Qy2, hv_g;

  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"green");
  HomMat2dIdentity(&hv_HomMat2DIdentity);
  hv_p = (HTuple(90).TupleRad())+hv_phi;
  if (0 != (hv_dir==0))
  {
    HomMat2dRotate(hv_HomMat2DIdentity, -hv_p, hv_x1, hv_y1, &hv_HomMat2DRotate2);
    AffineTransPoint2d(hv_HomMat2DRotate2, hv_x1+hv_margin, hv_y1, &hv_Qx1, &hv_Qy1);
    GenCrossContourXld(&ho_Cross1, hv_y1, hv_x1, 36, hv_phi);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Cross1, HDevWindowStack::GetActive());

    HomMat2dRotate(hv_HomMat2DIdentity, (-(HTuple(90).TupleRad()))-hv_phi, hv_x2, 
        hv_y2, &hv_HomMat2DRotate2);
    AffineTransPoint2d(hv_HomMat2DRotate2, hv_x2+hv_margin, hv_y2, &hv_Qx2, &hv_Qy2);
    GenCrossContourXld(&ho_Cross2, hv_y2, hv_x2, 36, hv_phi);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Cross2, HDevWindowStack::GetActive());
  }
  else
  {
    HomMat2dRotate(hv_HomMat2DIdentity, -hv_p, hv_x1, hv_y1, &hv_HomMat2DRotate2);
    AffineTransPoint2d(hv_HomMat2DRotate2, hv_x1, hv_y1+hv_margin, &hv_Qx1, &hv_Qy1);
    GenCrossContourXld(&ho_Cross3, hv_y1, hv_x1, 36, hv_phi);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Cross3, HDevWindowStack::GetActive());

    HomMat2dRotate(hv_HomMat2DIdentity, (-(HTuple(90).TupleRad()))-hv_phi, hv_x2, 
        hv_y2, &hv_HomMat2DRotate2);
    AffineTransPoint2d(hv_HomMat2DRotate2, hv_x2, hv_y2+hv_margin, &hv_Qx2, &hv_Qy2);
    GenCrossContourXld(&ho_Cross4, hv_y2, hv_x2, 36, hv_phi);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Cross4, HDevWindowStack::GetActive());
  }


  GenRegionLine(&ho_RegionLines, hv_Qy2, hv_Qx2, hv_y2, hv_x2);
  GenRegionLine(&ho_RegionLines1, hv_Qy1, hv_Qx1, hv_y1, hv_x1);
  GenRegionLine(&ho_RegionLines0, hv_y2, hv_x2, hv_y1, hv_x1);
  gen_arrow_contour_xld(&ho_Arrow, hv_Qy2, hv_Qx2, hv_Qy1, hv_Qx1, 25, 25);
  gen_arrow_contour_xld(&ho_Arrow2, hv_Qy1, hv_Qx1, hv_Qy2, hv_Qx2, 25, 25);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Arrow, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Arrow2, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_RegionLines, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_RegionLines1, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_RegionLines0, HDevWindowStack::GetActive());
  SetTposition(hv_windowhandle, (hv_Qy1+hv_Qy2)/2.0, (hv_Qx1+hv_Qx2)/2.0);
  hv_g = hv_value.TupleString(".4f");
  WriteString(hv_windowhandle, hv_g);
  return;
}

void DoubleCircle2 (HObject ho_imagesrc, HObject ho_regionsrc, HObject ho_regionref, 
    HTuple hv_deviation_value1, HTuple hv_deviation_value2, HTuple hv_deviation_value3, 
    HTuple hv_factor, HTuple hv_half_margin, HTuple hv_WindowHandle, HTuple hv_thr, 
    HTuple hv_sigma, HTuple *hv_isError, HTuple *hv_ErrorCode, HTuple *hv_length, 
    HTuple *hv_width, HTuple *hv_angle, HTuple *hv_center_x, HTuple *hv_center_y, 
    HTuple *hv_dis_rr, HTuple *hv_up_margin, HTuple *hv_down_margin)
{

  // Local iconic variables
  HObject  ho_ImageReduced, ho_Union, ho_RegionClosing;
  HObject  ho_RegionFillUp, ho_RegionErosion, ho_RegionDilation;
  HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_ObjectSelected1;
  HObject  ho_RegionTrans, ho_RegionTrans1, ho_ImageReduced1;
  HObject  ho_Cross, ho_Cross1, ho_Cross2, ho_RegionLines;
  HObject  ho_Contours, ho_RectangleLeft, ho_Rectangle, ho_ClippedContours;
  HObject  ho_ContCircle, ho_Cross3, ho_Rectangle1, ho_ClippedContours1;
  HObject  ho_ContCircle1, ho_Cross9, ho_CrossUp, ho_Cross4;
  HObject  ho_Cross5, ho_Cross6, ho_Cross7, ho_RegionLines1;
  HObject  ho_Cross10, ho_Cross8;

  // Local control variables
  HTuple  hv_Value, hv_gray_ref, hv_AreaRegion;
  HTuple  hv_Row5, hv_Column5, hv_th1, hv_Number1, hv_Row;
  HTuple  hv_Column, hv_Phi, hv_Length1, hv_Length2, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DRotate, hv_HomMat2DRotate2, hv_Qx, hv_Qy;
  HTuple  hv_Qx2, hv_Qy2, hv_Row11, hv_Column11, hv_Row2;
  HTuple  hv_Column2, hv_Row1, hv_Column1, hv_Radius, hv_StartPhi;
  HTuple  hv_EndPhi, hv_PointOrder, hv_Row12, hv_Column12;
  HTuple  hv_Row21, hv_Column21, hv_Radius2, hv_cen_x, hv_cen_y;
  HTuple  hv_HomMat0, hv_p, hv_HomMat0_R, hv_upx1, hv_upy1;
  HTuple  hv_dnx2, hv_dny2, hv_Phi1, hv_Row3, hv_Column3;
  HTuple  hv_Length11, hv_Length21, hv_HomMat2DIdentity3;
  HTuple  hv_Qx11, hv_Qy11, hv_Qx21, hv_Qy21, hv_Qx31, hv_Qy31;
  HTuple  hv_Qx41, hv_Qy41, hv_AmplitudeThreshold, hv_RoiWidthLen2;
  HTuple  hv_Sigma, hv_LineRowStart_Measure_01_0, hv_LineColumnStart_Measure_01_0;
  HTuple  hv_LineRowEnd_Measure_01_0, hv_LineColumnEnd_Measure_01_0;
  HTuple  hv_TmpCtrl_Row, hv_TmpCtrl_Column, hv_TmpCtrl_Dr;
  HTuple  hv_TmpCtrl_Dc, hv_TmpCtrl_Phi, hv_TmpCtrl_Len1;
  HTuple  hv_TmpCtrl_Len2, hv_MsrHandle_Measure_01_0, hv_Row_Measure_01_0;
  HTuple  hv_Column_Measure_01_0, hv_Amplitude_Measure_01_0;
  HTuple  hv_Distance_Measure_01_0, hv_up_x, hv_up_y, hv_dn_x;
  HTuple  hv_dn_y, hv_Row4, hv_Column4, hv_IsOverlapping;
  HTuple  hv_Distance, hv_Distance2, hv_Dis_pp, hv_Exception;
  HTuple  hv_ErrorMsg;

  (*hv_isError) = 0;
  (*hv_ErrorCode) = 0;


  try
  {
    //求参考平面灰度值
    GrayFeatures(ho_regionref, ho_imagesrc, "mean", &hv_Value);
    hv_gray_ref = hv_Value;
    //求出检测的区域的面积
    AreaCenter(ho_regionsrc, &hv_AreaRegion, &hv_Row5, &hv_Column5);
    //抠出目标
    //deviation_value1 := 50
    ReduceDomain(ho_imagesrc, ho_regionsrc, &ho_ImageReduced);
    //threshold (ImageReduced, Union, [0,242], [99,255])
    hv_th1 = 0;
    Threshold(ho_ImageReduced, &ho_Union, HTuple(0).TupleConcat(hv_gray_ref+hv_deviation_value2), 
        (hv_gray_ref-hv_deviation_value1).TupleConcat(255));

    //union1 (Union, Union)
    //预处理
    ClosingCircle(ho_Union, &ho_RegionClosing, 5.5);
    FillUp(ho_RegionClosing, &ho_RegionFillUp);
    ErosionCircle(ho_RegionFillUp, &ho_RegionErosion, 5.5);
    DilationCircle(ho_RegionErosion, &ho_RegionDilation, 5.5);
    Connection(ho_RegionDilation, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", hv_AreaRegion*(1/3.0), 
        hv_AreaRegion);
    CountObj(ho_SelectedRegions, &hv_Number1);
    if (0 != (hv_Number1<1))
    {
      (*hv_isError) = 1;
      (*hv_ErrorCode) = 1;
      //返回1
      return;
    }
    SelectObj(ho_SelectedRegions, &ho_ObjectSelected1, 1);
    //拟合成矩形 此时Length2接近圆的直径
    ShapeTrans(ho_ObjectSelected1, &ho_RegionTrans, "convex");
    ShapeTrans(ho_RegionTrans, &ho_RegionTrans1, "rectangle2");
    ReduceDomain(ho_ImageReduced, ho_RegionTrans1, &ho_ImageReduced1);
    SmallestRectangle2(ho_RegionTrans1, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, 
        &hv_Length2);
    GenCrossContourXld(&ho_Cross, hv_Row, hv_Column, 6, hv_Phi);
    //求两个最远的端点坐标
    HomMat2dIdentity(&hv_HomMat2DIdentity);
    HomMat2dRotate(hv_HomMat2DIdentity, -hv_Phi, hv_Column, hv_Row, &hv_HomMat2DRotate);
    HomMat2dRotate(hv_HomMat2DIdentity, hv_Phi, hv_Column, hv_Row, &hv_HomMat2DRotate2);
    AffineTransPoint2d(hv_HomMat2DRotate, hv_Column+hv_Length1, hv_Row, &hv_Qx, &hv_Qy);
    AffineTransPoint2d(hv_HomMat2DRotate, hv_Column-hv_Length1, hv_Row, &hv_Qx2, 
        &hv_Qy2);
    //最长距离的连线
    GenCrossContourXld(&ho_Cross1, hv_Qy2, hv_Qx2, 10, hv_Phi);
    GenCrossContourXld(&ho_Cross2, hv_Qy, hv_Qx, 10, hv_Phi);
    GenRegionLine(&ho_RegionLines, hv_Qy2, hv_Qx2, hv_Qy, hv_Qx);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_RegionLines, HDevWindowStack::GetActive());
    //left左圆
    GenContourRegionXld(ho_RegionTrans, &ho_Contours, "border");
    GenRectangle2(&ho_RectangleLeft, hv_Qy2, hv_Qx2, hv_Phi, hv_Length2+20, hv_Length2+20);

    SmallestRectangle1(ho_RectangleLeft, &hv_Row11, &hv_Column11, &hv_Row2, &hv_Column2);
    GenRectangle1(&ho_Rectangle, hv_Row11, hv_Column11, hv_Row2, hv_Column2);
    ClipContoursXld(ho_Contours, &ho_ClippedContours, hv_Row11, hv_Column11, hv_Row2, 
        hv_Column2);
    FitCircleContourXld(ho_ClippedContours, "geotukey", -1, 2, 0, 10, 1, &hv_Row1, 
        &hv_Column1, &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
    if (0 != ((hv_Row1.TupleLength())!=1))
    {
      (*hv_isError) = 1;
      (*hv_ErrorCode) = 2;
      //返回1
      return;
    }

    GenCircleContourXld(&ho_ContCircle, hv_Row1, hv_Column1, hv_Radius, 0, 6.28318, 
        "positive", 1);
    GenCrossContourXld(&ho_Cross3, hv_Row1, hv_Column1, 16, hv_Phi);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Cross3, HDevWindowStack::GetActive());
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ContCircle, HDevWindowStack::GetActive());
    //right右圆
    GenRectangle2(&ho_RectangleLeft, hv_Qy, hv_Qx, hv_Phi, hv_Length2+20, hv_Length2+20);
    SmallestRectangle1(ho_RectangleLeft, &hv_Row12, &hv_Column12, &hv_Row21, &hv_Column21);
    GenRectangle1(&ho_Rectangle1, hv_Row12, hv_Column12, hv_Row21, hv_Column21);
    ClipContoursXld(ho_Contours, &ho_ClippedContours1, hv_Row12, hv_Column12, hv_Row21, 
        hv_Column21);
    FitCircleContourXld(ho_ClippedContours1, "geotukey", -1, 2, 0, 10, 1, &hv_Row2, 
        &hv_Column2, &hv_Radius2, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
    if (0 != ((hv_Row2.TupleLength())!=1))
    {
      (*hv_isError) = 1;
      (*hv_ErrorCode) = 3;
      //返回3
      return;
    }
    GenCircleContourXld(&ho_ContCircle1, hv_Row2, hv_Column2, hv_Radius2, 0, 6.28318, 
        "positive", 1);
    GenCrossContourXld(&ho_Cross9, hv_Row2, hv_Column2, 16, hv_Phi);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ContCircle1, HDevWindowStack::GetActive());
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Cross9, HDevWindowStack::GetActive());
    //result
    //两个圆心连线的中心center point
    hv_cen_x = (hv_Column1+hv_Column2)/2.0;
    hv_cen_y = (hv_Row2+hv_Row1)/2.0;
    //
    HomMat2dIdentity(&hv_HomMat0);
    hv_p = (HTuple(90).TupleRad())+hv_Phi;
    HomMat2dRotate(hv_HomMat0, -hv_p, hv_Column2, hv_Row2, &hv_HomMat0_R);
    AffineTransPoint2d(hv_HomMat0_R, hv_Column2+hv_Radius2, hv_Row2, &hv_upx1, &hv_upy1);
    GenCrossContourXld(&ho_CrossUp, hv_upy1, hv_upx1, 36, hv_Phi);

    AffineTransPoint2d(hv_HomMat0_R, hv_Column2-hv_Radius2, hv_Row2, &hv_dnx2, &hv_dny2);
    GenCrossContourXld(&ho_CrossUp, hv_dny2, hv_dnx2, 36, hv_Phi);
    //
    //
    //
    hv_Phi1 = hv_Phi;
    hv_Row3 = hv_Row;
    hv_Column3 = hv_Column;
    hv_Length11 = hv_Length1+40;
    hv_Length21 = hv_Length2+hv_half_margin;
    HomMat2dIdentity(&hv_HomMat2DIdentity3);
    HomMat2dRotate(hv_HomMat2DIdentity3, -hv_Phi1, hv_Row3, hv_Column3, &hv_HomMat2DRotate2);
    AffineTransPoint2d(hv_HomMat2DRotate2, hv_Column3+hv_Length11, hv_Row3+hv_Length21, 
        &hv_Qx11, &hv_Qy11);
    GenCrossContourXld(&ho_Cross4, hv_Qy11, hv_Qx11, 6, hv_Phi1);
    AffineTransPoint2d(hv_HomMat2DRotate2, hv_Column3-hv_Length11, hv_Row3+hv_Length21, 
        &hv_Qx21, &hv_Qy21);
    GenCrossContourXld(&ho_Cross5, hv_Qy21, hv_Qx21, 6, hv_Phi1);
    AffineTransPoint2d(hv_HomMat2DRotate2, hv_Column3-hv_Length11, hv_Row3-hv_Length21, 
        &hv_Qx31, &hv_Qy31);
    GenCrossContourXld(&ho_Cross6, hv_Qy31, hv_Qx31, 6, hv_Phi1);
    AffineTransPoint2d(hv_HomMat2DRotate2, hv_Column3+hv_Length11, hv_Row3-hv_Length21, 
        &hv_Qx41, &hv_Qy41);
    GenCrossContourXld(&ho_Cross7, hv_Qy41, hv_Qx41, 6, hv_Phi1);
    //求出边缘点
    //Measure 01: Code generated by Measure 01
    //Measure 01: Prepare measurement

    //AmplitudeThreshold := 24
    hv_AmplitudeThreshold = hv_thr;
    hv_RoiWidthLen2 = 60.5;
    //Sigma := 4
    hv_Sigma = hv_sigma;
    SetSystem("int_zooming", "true");
    //Measure 01: Coordinates for line Measure 01 [0]
    hv_LineRowStart_Measure_01_0 = hv_Qy41;
    hv_LineColumnStart_Measure_01_0 = hv_Qx41;
    hv_LineRowEnd_Measure_01_0 = hv_Qy11;
    hv_LineColumnEnd_Measure_01_0 = hv_Qx11;
    //Measure 01: Convert coordinates to rectangle2 type
    hv_TmpCtrl_Row = 0.5*(hv_LineRowStart_Measure_01_0+hv_LineRowEnd_Measure_01_0);
    hv_TmpCtrl_Column = 0.5*(hv_LineColumnStart_Measure_01_0+hv_LineColumnEnd_Measure_01_0);
    hv_TmpCtrl_Dr = hv_LineRowStart_Measure_01_0-hv_LineRowEnd_Measure_01_0;
    hv_TmpCtrl_Dc = hv_LineColumnEnd_Measure_01_0-hv_LineColumnStart_Measure_01_0;
    hv_TmpCtrl_Phi = hv_TmpCtrl_Dr.TupleAtan2(hv_TmpCtrl_Dc);
    hv_TmpCtrl_Len1 = 0.5*(((hv_TmpCtrl_Dr*hv_TmpCtrl_Dr)+(hv_TmpCtrl_Dc*hv_TmpCtrl_Dc)).TupleSqrt());
    hv_TmpCtrl_Len2 = hv_RoiWidthLen2;
    //Measure 01: Create measure for line Measure 01 [0]
    //Measure 01: Attention: This assumes all images have the same size!
    GenMeasureRectangle2(hv_TmpCtrl_Row, hv_TmpCtrl_Column, hv_TmpCtrl_Phi, hv_TmpCtrl_Len1, 
        hv_TmpCtrl_Len2, 4024, 3036, "nearest_neighbor", &hv_MsrHandle_Measure_01_0);
    GenRegionLine(&ho_RegionLines1, hv_LineRowStart_Measure_01_0, hv_LineColumnStart_Measure_01_0, 
        hv_LineRowEnd_Measure_01_0, hv_LineColumnEnd_Measure_01_0);
    //Measure 01: ***************************************************************
    //Measure 01: * The code which follows is to be executed once / measurement *
    //Measure 01: ***************************************************************
    //Measure 01: *************
    //Measure 01: * ATTENTION *
    //Measure 01: *************
    //Measure 01: The image from the graphics window is not available. At this point,
    //Measure 01: it is necessary to ensure an image is stored in the variable 'Image'
    //Measure 01: Execute measurements
    MeasurePos(ho_imagesrc, hv_MsrHandle_Measure_01_0, hv_Sigma, hv_AmplitudeThreshold, 
        "all", "all", &hv_Row_Measure_01_0, &hv_Column_Measure_01_0, &hv_Amplitude_Measure_01_0, 
        &hv_Distance_Measure_01_0);
    //Measure 01: Do something with the results
    GenCrossContourXld(&ho_Cross10, hv_Row_Measure_01_0, hv_Column_Measure_01_0, 
        6, hv_Phi);
    //Measure 01: Clear measure when done
    CloseMeasure(hv_MsrHandle_Measure_01_0);
    //****************************************************************************
    if (0 != ((hv_Row_Measure_01_0.TupleLength())==4))
    {
      hv_up_x = ((const HTuple&)hv_Column_Measure_01_0)[1];
      hv_up_y = ((const HTuple&)hv_Row_Measure_01_0)[1];
      hv_dn_x = ((const HTuple&)hv_Column_Measure_01_0)[2];
      hv_dn_y = ((const HTuple&)hv_Row_Measure_01_0)[2];
    }
    else
    {
      (*hv_isError) = 1;
      (*hv_ErrorCode) = 6;
      //返回3
      return;
    }
    //交点
    IntersectionLines(hv_up_y, hv_up_x, hv_dn_y, hv_dn_x, hv_Qy2, hv_Qx2, hv_Qy, 
        hv_Qx, &hv_Row4, &hv_Column4, &hv_IsOverlapping);
    GenCrossContourXld(&ho_Cross8, hv_Row4, hv_Column4, 6, hv_Phi1);
    //中心线到目标线的长度
    DistancePp(hv_Row4, hv_Column4, hv_up_y, hv_up_x, &hv_Distance);
    DistancePp(hv_Row4, hv_Column4, hv_dn_y, hv_dn_x, &hv_Distance2);
    //求两个圆心之间的距离
    DistancePp(hv_Row2, hv_Column2, hv_Row1, hv_Column1, &hv_Dis_pp);
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    HalconCpp::HException::GetExceptionData(hv_Exception,"error_msg",&hv_ErrorMsg);
    disp_message(hv_WindowHandle, "Error message: "+hv_ErrorMsg, "window", 12, 12, 
        "red", "true");
    (*hv_isError) = 1;
    (*hv_ErrorCode) = 4;
    //返回1
    return;
  }
  //返回值
  (*hv_dis_rr) = hv_Dis_pp*hv_factor;
  //长度
  (*hv_length) = ((hv_Dis_pp+hv_Radius2)+hv_Radius)*hv_factor;
  //宽度
  (*hv_width) = (hv_Radius2+hv_Radius)*hv_factor;
  //角度方向（弧度制）
  (*hv_angle) = hv_Phi1;
  //中心点 x坐标
  (*hv_center_x) = hv_cen_x*hv_factor;
  (*hv_center_y) = hv_cen_y*hv_factor;
  //上边缘距离中轴线
  (*hv_up_margin) = hv_Distance*hv_factor;
  (*hv_down_margin) = hv_Distance2*hv_factor;

  //两个圆心之间的距离
  DrawIndica(hv_Column1, hv_Row1, hv_Column2, hv_Row2, hv_Phi1, hv_Radius*3, (*hv_dis_rr), 
      hv_WindowHandle, 0);
  DrawIndica(hv_Qx, hv_Qy, hv_Qx2, hv_Qy2, hv_Phi1, hv_Radius*4, (*hv_length), hv_WindowHandle, 
      0);
  DrawIndica(hv_upx1, hv_upy1, hv_dnx2, hv_dny2, hv_Phi, hv_Radius+100, (*hv_width), 
      hv_WindowHandle, 1);
  DrawIndica(hv_Column4, hv_Row4, hv_up_x, hv_up_y, hv_Phi1, hv_Radius*2, (*hv_up_margin), 
      hv_WindowHandle, 1);
  DrawIndica(hv_Column4, hv_Row4, hv_dn_x, hv_dn_y, hv_Phi1, hv_Radius*2, (*hv_down_margin), 
      hv_WindowHandle, 1);
  return;
}

void SingleCircle (HObject ho_imagesrc, HObject ho_regionsrc, HObject ho_regionref, 
    HTuple hv_deviation_value1, HTuple hv_deviation_value2, HTuple hv_factor, HTuple hv_WindowHandle, 
    HTuple *hv_length, HTuple *hv_center_x, HTuple *hv_center_y, HTuple *hv_isError, 
    HTuple *hv_ErrorCode)
{

  // Local iconic variables
  HObject  ho_ImageReduced, ho_Union, ho_RegionClosing;
  HObject  ho_RegionFillUp, ho_RegionErosion, ho_RegionDilation;
  HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_ObjectSelected1;
  HObject  ho_Contours, ho_ContCircle;

  // Local control variables
  HTuple  hv_Value, hv_gray_ref, hv_AreaRegion;
  HTuple  hv_Row5, hv_Column5, hv_Number1, hv_Row1, hv_Column1;
  HTuple  hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder;
  HTuple  hv_x1, hv_y1, hv_x2, hv_y2, hv_Length, hv_Exception;
  HTuple  hv_ErrorMsg;

  (*hv_isError) = 0;
  (*hv_ErrorCode) = 0;

  try
  {
    //求参考平面灰度值
    GrayFeatures(ho_regionref, ho_imagesrc, "mean", &hv_Value);
    hv_gray_ref = hv_Value;
    //求出检测的区域的面积
    AreaCenter(ho_regionsrc, &hv_AreaRegion, &hv_Row5, &hv_Column5);
    //抠出目标
    //deviation_value1 := 50
    ReduceDomain(ho_imagesrc, ho_regionsrc, &ho_ImageReduced);

    Threshold(ho_ImageReduced, &ho_Union, HTuple(0).TupleConcat(hv_gray_ref+hv_deviation_value2), 
        (hv_gray_ref-hv_deviation_value1).TupleConcat(255));
    Union1(ho_Union, &ho_Union);
    //预处理
    ClosingCircle(ho_Union, &ho_RegionClosing, 5.5);
    FillUp(ho_RegionClosing, &ho_RegionFillUp);
    ErosionCircle(ho_RegionFillUp, &ho_RegionErosion, 5.5);
    DilationCircle(ho_RegionErosion, &ho_RegionDilation, 5.5);
    Connection(ho_RegionDilation, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "roundness", "and", 0.8092, 
        2);
    CountObj(ho_SelectedRegions, &hv_Number1);
    if (0 != (hv_Number1<1))
    {
      (*hv_isError) = 1;
      (*hv_ErrorCode) = 1;
      //返回1
      return;
    }
    SelectObj(ho_SelectedRegions, &ho_ObjectSelected1, 1);
    GenContourRegionXld(ho_ObjectSelected1, &ho_Contours, "border");
    FitCircleContourXld(ho_Contours, "geotukey", -1, 2, 0, 10, 1, &hv_Row1, &hv_Column1, 
        &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
    if (0 != ((hv_Row1.TupleLength())!=1))
    {
      (*hv_isError) = 1;
      (*hv_ErrorCode) = 2;
      //返回1
      return;
    }
    GenCircleContourXld(&ho_ContCircle, hv_Row1, hv_Column1, hv_Radius, 0, 6.28318, 
        "positive", 1);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_ContCircle, HDevWindowStack::GetActive());
    hv_x1 = hv_Column1;
    hv_y1 = hv_Row1-hv_Radius;
    hv_x2 = hv_Column1;
    hv_y2 = hv_Row1+hv_Radius;
    hv_Length = (hv_Radius*2)*hv_factor;
    (*hv_length) = hv_Length;
    (*hv_center_x) = hv_Column1;
    (*hv_center_y) = hv_Row1;
    DrawIndica(hv_x1, hv_y1, hv_x2, hv_y2, 0, hv_Radius*2.5, hv_Length, hv_WindowHandle, 
        1);
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    HalconCpp::HException::GetExceptionData(hv_Exception,"error_msg",&hv_ErrorMsg);
    disp_message(hv_WindowHandle, "Error message: "+hv_ErrorMsg, "window", 12, 12, 
        "red", "true");
    (*hv_isError) = 1;
    (*hv_ErrorCode) = 4;
    //返回1
    return;
  }
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_ROI_0, ho_ROI_REF;

  // Local control variables
  HTuple  hv_deviation_value1, hv_deviation_value2;
  HTuple  hv_deviation_value3, hv_factor, hv_half_margin;
  HTuple  hv_thr, hv_sigma, hv_isError, hv_ErrorCode, hv_length;
  HTuple  hv_width, hv_angle, hv_center_x, hv_center_y, hv_dis_rr;
  HTuple  hv_up_margin, hv_down_margin, hv_radius, hv_center_x1;
  HTuple  hv_center_y1, hv_isError1, hv_ErrorCode1;

  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"green");
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  dev_update_off();
  ReadImage(&ho_Image, "E:/5678/Checker5678_20190828/Checker5678/Image_20191214155002125.bmp");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Image, HDevWindowStack::GetActive());
  //gen_rectangle1 (ROI_0, 1413.18, 3314.03, 1660.33, 3553.89)
  GenRectangle2(&ho_ROI_0, 1024.89, 1402.74, HTuple(4.21657).TupleRad(), 1397.9, 
      185.084);
  GenRectangle1(&ho_ROI_REF, 882.575, 2842.9, 1036.75, 2922.45);

  //gen_rectangle2 (ROI_0, 1415.08, 1458.21, rad(-3.34037), 1341.78, 259.067)
  //gen_rectangle1 (ROI_REF, 1325.29, 2922.97, 1453.89, 3080.64)
  //孔的灰度相对于参考平面的偏移量
  hv_deviation_value1 = 110;
  //上下边缘灰度相对于参考平面的偏移量
  hv_deviation_value2 = 20;
  hv_deviation_value3 = 70;
  //像素与物理尺寸的比例， mm/pix
  hv_factor = 0.00782186295619339578507368045917;
  //0.00814423770749481619269917954949
  //孔位距离上缘的框选距离
  hv_half_margin = 180;
  hv_thr = 24;
  hv_sigma = 4;
  DoubleCircle2(ho_Image, ho_ROI_0, ho_ROI_REF, hv_deviation_value1, hv_deviation_value2, 
      hv_deviation_value3, hv_factor, hv_half_margin, 3600, hv_thr, hv_sigma, &hv_isError, 
      &hv_ErrorCode, &hv_length, &hv_width, &hv_angle, &hv_center_x, &hv_center_y, 
      &hv_dis_rr, &hv_up_margin, &hv_down_margin);

  GenRectangle1(&ho_ROI_0, 806.573, 3129.63, 1004.14, 3362.44);
  //gen_rectangle1 (ROI_0, 1398.98, 3275.29, 1697.26, 3602.62)
  GenRectangle1(&ho_ROI_REF, 871.483, 3053.11, 977.798, 3147.9);
  hv_factor = 0.00814423770749481619269917954949;
  SingleCircle(ho_Image, ho_ROI_0, ho_ROI_REF, hv_deviation_value1, hv_deviation_value2, 
      hv_factor, 3600, &hv_radius, &hv_center_x1, &hv_center_y1, &hv_isError1, &hv_ErrorCode1);
  return;
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
HTuple      gStartMutex;
H_pthread_t gActionThread;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  LockMutex(gStartMutex);
  action();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRunLoopRun();
  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  // Default settings used in HDevelop (can be omitted) 
  int ret=0;
  SetSystem("width", 512);
  SetSystem("height", 512);

#if defined(_WIN32)
  SetSystem("use_window_thread", "true");
#elif defined(__linux__)
  XInitThreads();
#endif

#ifndef __APPLE__
  action();
#else
  ret = apple_main(argc,argv);
#endif
  return ret;
}

#endif


#endif


