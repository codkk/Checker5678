<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="12.0">
<procedure name="main">
<interface/>
<body>
<l>dev_set_color ('green')</l>
<l>dev_set_draw ('margin')</l>
<l>dev_update_off ()</l>
<l>read_image (Image, 'E:/5678/Checker5678_20190828/Checker5678/Image_20191214155002125.bmp')</l>
<l>dev_display (Image)</l>
<l>*gen_rectangle1 (ROI_0, 1413.18, 3314.03, 1660.33, 3553.89)</l>
<l>gen_rectangle2 (ROI_0, 1024.89, 1402.74, rad(4.21657), 1397.9, 185.084)</l>
<l>gen_rectangle1 (ROI_REF, 882.575, 2842.9, 1036.75, 2922.45)</l>
<c></c>
<l>*gen_rectangle2 (ROI_0, 1415.08, 1458.21, rad(-3.34037), 1341.78, 259.067)</l>
<l>*gen_rectangle1 (ROI_REF, 1325.29, 2922.97, 1453.89, 3080.64)</l>
<c>*孔的灰度相对于参考平面的偏移量</c>
<l>deviation_value1:=110</l>
<c>*上下边缘灰度相对于参考平面的偏移量</c>
<l>deviation_value2:=20</l>
<l>deviation_value3:=70</l>
<c>*像素与物理尺寸的比例， mm/pix</c>
<l>factor:=0.00782186295619339578507368045917</l>
<c>*0.00814423770749481619269917954949</c>
<c>*孔位距离上缘的框选距离</c>
<l>half_margin:=230</l>
<l>DoubleCircle (Image, ROI_0, ROI_REF, deviation_value1, deviation_value2, deviation_value3, factor, half_margin, 3600, isError, ErrorCode, length, width, angle, center_x, center_y, dis_rr, up_margin, down_margin)</l>
<c></c>
<l>gen_rectangle1 (ROI_0, 806.573, 3129.63, 1004.14, 3362.44)</l>
<l>*gen_rectangle1 (ROI_0, 1398.98, 3275.29, 1697.26, 3602.62)</l>
<l>gen_rectangle1 (ROI_REF, 871.483, 3053.11, 977.798, 3147.9)</l>
<l>factor:=0.00814423770749481619269917954949</l>
<l>SingleCircle (Image, ROI_0, ROI_REF, deviation_value1, deviation_value2, factor, 3600, radius, center_x1, center_y1, isError1, ErrorCode1)</l>
<l>return ()</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="DrawIndica">
<interface>
<ic>
<par name="x1" base_type="ctrl" dimension="0"/>
<par name="y1" base_type="ctrl" dimension="0"/>
<par name="x2" base_type="ctrl" dimension="0"/>
<par name="y2" base_type="ctrl" dimension="0"/>
<par name="phi" base_type="ctrl" dimension="0"/>
<par name="margin" base_type="ctrl" dimension="0"/>
<par name="value" base_type="ctrl" dimension="0"/>
<par name="windowhandle" base_type="ctrl" dimension="0"/>
<par name="dir" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dev_set_color ('green')</l>
<l>hom_mat2d_identity (HomMat2DIdentity)</l>
<l>p:=rad(90)+phi</l>
<l>if (dir==0)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -p, x1, y1,HomMat2DRotate2)</l>
<l>    affine_trans_point_2d (HomMat2DRotate2, x1+margin, y1, Qx1, Qy1)</l>
<l>    gen_cross_contour_xld (Cross1, y1, x1, 36, phi)</l>
<l>    dev_display (Cross1)</l>
<c>    </c>
<l>    hom_mat2d_rotate (HomMat2DIdentity,  -rad(90)-phi, x2, y2,HomMat2DRotate2)</l>
<l>    affine_trans_point_2d (HomMat2DRotate2, x2+margin, y2, Qx2, Qy2)</l>
<l>    gen_cross_contour_xld (Cross2, y2, x2, 36, phi)</l>
<l>    dev_display (Cross2)    </l>
<l>else</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -p, x1, y1,HomMat2DRotate2)</l>
<l>    affine_trans_point_2d (HomMat2DRotate2, x1, y1+margin, Qx1, Qy1)</l>
<l>    gen_cross_contour_xld (Cross3, y1, x1, 36, phi)</l>
<l>    dev_display (Cross3)</l>
<c>    </c>
<l>    hom_mat2d_rotate (HomMat2DIdentity,  -rad(90)-phi, x2, y2,HomMat2DRotate2)</l>
<l>    affine_trans_point_2d (HomMat2DRotate2, x2, y2+margin, Qx2, Qy2)</l>
<l>    gen_cross_contour_xld (Cross4, y2, x2, 36, phi)</l>
<l>    dev_display (Cross4)   </l>
<l>endif</l>
<c></c>
<c></c>
<l>gen_region_line (RegionLines, Qy2, Qx2, y2, x2)</l>
<l>gen_region_line (RegionLines1, Qy1, Qx1,  y1, x1)</l>
<l>gen_region_line (RegionLines0, y2, x2, y1, x1)</l>
<l>gen_arrow_contour_xld (Arrow, Qy2, Qx2, Qy1, Qx1, 25, 25)</l>
<l>gen_arrow_contour_xld (Arrow2, Qy1, Qx1, Qy2, Qx2, 25, 25)</l>
<l>dev_display (Arrow)</l>
<l>dev_display (Arrow2)</l>
<l>dev_display (RegionLines)</l>
<l>dev_display (RegionLines1)</l>
<l>dev_display (RegionLines0)</l>
<l>set_tposition (windowhandle, (Qy1+Qy2)/2.0, (Qx1+Qx2)/2.0)</l>
<l>g:=value$'.4f'</l>
<l>write_string (windowhandle, g)</l>
<l>return ()</l>
</body>
<docu id="DrawIndica">
<parameters>
<parameter id="dir">
<default_value>0</default_value>
<description lang="zh_CN">方向， 0代表水平画， 1代表垂直画</description>
<sem_type>integer</sem_type>
<type_list>
<item>integer</item>
</type_list>
</parameter>
<parameter id="margin"/>
<parameter id="phi"/>
<parameter id="value"/>
<parameter id="windowhandle"/>
<parameter id="x1"/>
<parameter id="x2"/>
<parameter id="y1"/>
<parameter id="y2"/>
</parameters>
</docu>
</procedure>
<procedure name="DoubleCircle">
<interface>
<io>
<par name="imagesrc" base_type="iconic" dimension="0"/>
<par name="regionsrc" base_type="iconic" dimension="0"/>
<par name="regionref" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="deviation_value1" base_type="ctrl" dimension="0"/>
<par name="deviation_value2" base_type="ctrl" dimension="0"/>
<par name="deviation_value3" base_type="ctrl" dimension="0"/>
<par name="factor" base_type="ctrl" dimension="0"/>
<par name="half_margin" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="isError" base_type="ctrl" dimension="0"/>
<par name="ErrorCode" base_type="ctrl" dimension="0"/>
<par name="length" base_type="ctrl" dimension="0"/>
<par name="width" base_type="ctrl" dimension="0"/>
<par name="angle" base_type="ctrl" dimension="0"/>
<par name="center_x" base_type="ctrl" dimension="0"/>
<par name="center_y" base_type="ctrl" dimension="0"/>
<par name="dis_rr" base_type="ctrl" dimension="0"/>
<par name="up_margin" base_type="ctrl" dimension="0"/>
<par name="down_margin" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>isError:=false</l>
<l>ErrorCode:=0</l>
<c></c>
<c></c>
<l>try</l>
<c>    *求参考平面灰度值</c>
<l>    gray_features (regionref, imagesrc, 'mean', Value)</l>
<l>    gray_ref:=Value</l>
<c>    *求出检测的区域的面积</c>
<l>    area_center (regionsrc, AreaRegion, Row5, Column5)</l>
<c>    *抠出目标</c>
<l>*    deviation_value1:=50</l>
<l>    reduce_domain (imagesrc, regionsrc, ImageReduced)</l>
<l>    *threshold (ImageReduced, Union, [0,242], [99,255])</l>
<l>    th1:=0</l>
<l>    threshold (ImageReduced, Union, [0,gray_ref+deviation_value2], [gray_ref-deviation_value1,255])    </l>
<c></c>
<l>    *union1 (Union, Union)</l>
<c>    *预处理</c>
<l>    closing_circle (Union, RegionClosing, 5.5)</l>
<l>    fill_up (RegionClosing, RegionFillUp)</l>
<l>    erosion_circle (RegionFillUp, RegionErosion, 5.5)</l>
<l>    dilation_circle (RegionErosion, RegionDilation, 5.5)</l>
<l>    connection (RegionDilation, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', AreaRegion*(1/3.0), AreaRegion)</l>
<l>    count_obj (SelectedRegions, Number1)</l>
<l>    if(Number1 &lt;1)</l>
<l>        isError:=true</l>
<l>        ErrorCode:=1</l>
<c>        *返回1</c>
<l>        return ()</l>
<l>    endif</l>
<l>    select_obj (SelectedRegions, ObjectSelected1, 1)</l>
<c>    *拟合成矩形 此时Length2接近圆的直径</c>
<l>    shape_trans (ObjectSelected1, RegionTrans, 'convex')</l>
<l>    shape_trans (RegionTrans, RegionTrans1, 'rectangle2')</l>
<l>    reduce_domain (ImageReduced, RegionTrans1, ImageReduced1)</l>
<l>    smallest_rectangle2 (RegionTrans1, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_cross_contour_xld (Cross, Row, Column, 6, Phi)</l>
<c>    *求两个最远的端点坐标</c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -Phi, Column, Row, HomMat2DRotate)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, Phi, Column, Row, HomMat2DRotate2)</l>
<l>    affine_trans_point_2d (HomMat2DRotate, Column+Length1, Row, Qx, Qy)</l>
<l>    affine_trans_point_2d (HomMat2DRotate, Column-Length1, Row, Qx2, Qy2)</l>
<c>    *最长距离的连线</c>
<l>    gen_cross_contour_xld (Cross1, Qy2, Qx2, 10, Phi)</l>
<l>    gen_cross_contour_xld (Cross2, Qy, Qx, 10, Phi)</l>
<l>    gen_region_line (RegionLines, Qy2, Qx2, Qy, Qx)</l>
<l>    dev_display (RegionLines)</l>
<c>    *left左圆</c>
<l>    gen_contour_region_xld (RegionTrans, Contours, 'border')</l>
<l>    gen_rectangle2 (RectangleLeft, Qy2, Qx2, Phi, Length2+20, Length2+20)</l>
<c>    </c>
<l>    smallest_rectangle1 (RectangleLeft, Row11, Column11, Row2, Column2)</l>
<l>    gen_rectangle1 (Rectangle, Row11, Column11, Row2, Column2)</l>
<l>    clip_contours_xld (Contours, ClippedContours, Row11, Column11, Row2, Column2)</l>
<l>    fit_circle_contour_xld (ClippedContours, 'geotukey', -1, 2, 0, 10, 1, Row1, Column1, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>    if(|Row1| != 1)</l>
<l>        isError:=true</l>
<l>        ErrorCode:=2</l>
<c>        *返回1</c>
<l>        return ()</l>
<l>    endif</l>
<c>    </c>
<l>    gen_circle_contour_xld (ContCircle, Row1, Column1, Radius, 0, 6.28318, 'positive', 1)</l>
<l>    gen_cross_contour_xld (Cross3,  Row1, Column1, 16, Phi)</l>
<l>    dev_display (Cross3)</l>
<l>    dev_display(ContCircle)</l>
<c>    *right右圆</c>
<l>    gen_rectangle2 (RectangleLeft, Qy, Qx, Phi, Length2+20, Length2+20)</l>
<l>    smallest_rectangle1 (RectangleLeft, Row12, Column12, Row21, Column21)</l>
<l>    gen_rectangle1 (Rectangle1, Row12, Column12, Row21, Column21)</l>
<l>    clip_contours_xld (Contours, ClippedContours1, Row12, Column12, Row21, Column21)</l>
<l>    fit_circle_contour_xld (ClippedContours1, 'geotukey', -1, 2, 0, 10, 1, Row2, Column2, Radius2, StartPhi, EndPhi, PointOrder)</l>
<l>    if(|Row2| != 1)</l>
<l>        isError:=true</l>
<l>        ErrorCode:=3</l>
<c>        *返回3</c>
<l>        return ()</l>
<l>    endif</l>
<l>    gen_circle_contour_xld (ContCircle1, Row2, Column2, Radius2 , 0, 6.28318, 'positive', 1)</l>
<l>    gen_cross_contour_xld (Cross9, Row2, Column2, 16, Phi)</l>
<l>    dev_display (ContCircle1)</l>
<l>    dev_display (Cross9)</l>
<c>    *result</c>
<c>    *两个圆心连线的中心center point</c>
<l>    cen_x := (Column1 + Column2)/2.0</l>
<l>    cen_y := (Row2 + Row1)/2.0</l>
<c>    *</c>
<l>    hom_mat2d_identity (HomMat0)</l>
<l>    p:=rad(90)+Phi</l>
<l>    hom_mat2d_rotate (HomMat0, -p, Column2, Row2, HomMat0_R)</l>
<l>    affine_trans_point_2d (HomMat0_R, Column2+Radius2, Row2, upx1, upy1)</l>
<l>    gen_cross_contour_xld (CrossUp, upy1,upx1, 36, Phi)</l>
<c>    </c>
<l>    affine_trans_point_2d (HomMat0_R, Column2-Radius2, Row2, dnx2, dny2)</l>
<l>    gen_cross_contour_xld (CrossUp, dny2, dnx2, 36, Phi)</l>
<c>    *求边缘到中轴线的距离</c>
<l>    gen_rectangle2 (ROI_2,  Row, Column, Phi, Length1+40, Length2+half_margin)</l>
<l>    reduce_domain (imagesrc, ROI_2, ImageReduced2)</l>
<l>*    deviation_value2:=10</l>
<c>    </c>
<l>    threshold (ImageReduced2, Regions2, gray_ref-deviation_value3, 255)</l>
<c>    *计算检测框的面积</c>
<l>    area_center (ROI_2, Area_big, Row6, Column6)</l>
<l>    fill_up (Regions2, RegionFillUp1)</l>
<l>    erosion_rectangle1 (RegionFillUp1, RegionErosion1, 11, 11)</l>
<l>    dilation_rectangle1 (RegionErosion1, RegionDilation1, 11, 11)</l>
<c>    </c>
<l>    connection (RegionDilation1, ConnectedRegions1)</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', Area_big*(1/5.0), Area_big)</l>
<l>    count_obj (SelectedRegions1, Number2)</l>
<l>    if(Number2 &lt;1)</l>
<l>        isError:=true</l>
<l>        ErrorCode:=3</l>
<c>        *返回1</c>
<l>        return ()</l>
<l>    endif</l>
<l>    select_obj (SelectedRegions1, ObjectSelected, 1)</l>
<l>    shape_trans (ObjectSelected, RegionTrans2, 'rectangle2')</l>
<l>    smallest_rectangle2 (RegionTrans2, Row3, Column3, Phi1, Length11, Length21)</l>
<l>*    gen_cross_contour_xld (Cross5, Row3, Column3, 6, Phi1)</l>
<c>    </c>
<l>    hom_mat2d_identity (HomMat2DIdentity3)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity3, -Phi1, Row3, Column3,HomMat2DRotate2)</l>
<l>    affine_trans_point_2d (HomMat2DRotate2, Column3+Length11, Row3+Length21, Qx11, Qy11)</l>
<l>    gen_cross_contour_xld (Cross4, Qy11, Qx11, 6, Phi1)</l>
<l>    affine_trans_point_2d (HomMat2DRotate2, Column3 -Length11, Row3+Length21, Qx21, Qy21)</l>
<l>    gen_cross_contour_xld (Cross5, Qy21, Qx21, 6, Phi1)</l>
<l>    affine_trans_point_2d (HomMat2DRotate2, Column3-Length11, Row3-Length21, Qx31, Qy31)</l>
<l>    gen_cross_contour_xld (Cross6, Qy31, Qx31, 6, Phi1)</l>
<l>    affine_trans_point_2d (HomMat2DRotate2, Column3+Length11, Row3-Length21, Qx41, Qy41)</l>
<l>    gen_cross_contour_xld (Cross7, Qy41, Qx41, 6, Phi1)</l>
<c>    *交点</c>
<l>    intersection_lines (Qy41, Qx41, Qy11, Qx11,   Qy2, Qx2, Qy, Qx, Row4, Column4, IsOverlapping)</l>
<l>    gen_cross_contour_xld (Cross8, Row4, Column4, 6, Phi1)</l>
<c>    *中心线到目标线的长度</c>
<l>    distance_pp (Row4, Column4,Qy41, Qx41, Distance)</l>
<l>    distance_pp (Row4, Column4,Qy11, Qx11, Distance2)</l>
<c>    *求两个圆心之间的距离</c>
<l>    distance_pp (Row2, Column2,Row1, Column1, Dis_pp)</l>
<l>catch (Exception)</l>
<l>    dev_get_exception_data (Exception, 'error_msg', ErrorMsg)</l>
<l>    disp_message (WindowHandle, 'Error message: ' + ErrorMsg, 'window', 12, 12, 'red', 'true')</l>
<l>    isError:=true</l>
<l>    ErrorCode:=4</l>
<c>    *返回1</c>
<l>    return ()</l>
<l>endtry</l>
<c>*返回值</c>
<l>dis_rr := Dis_pp*factor</l>
<c>*长度</c>
<l>length:= (Dis_pp+Radius2+Radius)*factor</l>
<c>*宽度</c>
<l>width:= (Radius2+Radius)*factor</l>
<c>*角度方向（弧度制）</c>
<l>angle:=Phi1</l>
<c>*中心点 x坐标</c>
<l>center_x :=cen_x*factor</l>
<l>center_y :=cen_y*factor</l>
<c>*上边缘距离中轴线</c>
<l>up_margin := Distance*factor</l>
<l>down_margin := Distance2*factor</l>
<c></c>
<c>*两个圆心之间的距离</c>
<l>DrawIndica (Column1, Row1, Column2, Row2, Phi1, Radius*3, dis_rr, WindowHandle, 0)</l>
<l>DrawIndica (Qx, Qy, Qx2, Qy2, Phi1, Radius*4, length, WindowHandle, 0)</l>
<l>DrawIndica (upx1, upy1, dnx2, dny2, Phi, Radius+100, width, WindowHandle, 1)</l>
<l>DrawIndica (Column4, Row4, Qx41, Qy41, Phi1, Radius*2, up_margin, WindowHandle, 1)</l>
<l>DrawIndica (Column4, Row4, Qx11, Qy11, Phi1, Radius*2, down_margin, WindowHandle, 1)</l>
<l>return ()</l>
</body>
<docu id="DoubleCircle">
<parameters>
<parameter id="ErrorCode"/>
<parameter id="WindowHandle"/>
<parameter id="angle"/>
<parameter id="center_x"/>
<parameter id="center_y"/>
<parameter id="deviation_value1"/>
<parameter id="deviation_value2"/>
<parameter id="deviation_value3"/>
<parameter id="dis_rr"/>
<parameter id="down_margin"/>
<parameter id="factor"/>
<parameter id="half_margin"/>
<parameter id="imagesrc"/>
<parameter id="isError"/>
<parameter id="length"/>
<parameter id="regionref"/>
<parameter id="regionsrc"/>
<parameter id="up_margin"/>
<parameter id="width"/>
</parameters>
</docu>
</procedure>
<procedure name="SingleCircle">
<interface>
<io>
<par name="imagesrc" base_type="iconic" dimension="0"/>
<par name="regionsrc" base_type="iconic" dimension="0"/>
<par name="regionref" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="deviation_value1" base_type="ctrl" dimension="0"/>
<par name="deviation_value2" base_type="ctrl" dimension="0"/>
<par name="factor" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="length" base_type="ctrl" dimension="0"/>
<par name="center_x" base_type="ctrl" dimension="0"/>
<par name="center_y" base_type="ctrl" dimension="0"/>
<par name="isError" base_type="ctrl" dimension="0"/>
<par name="ErrorCode" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>isError:=false</l>
<l>ErrorCode:=0</l>
<c></c>
<l>try</l>
<c>    *求参考平面灰度值</c>
<l>    gray_features (regionref, imagesrc, 'mean', Value)</l>
<l>    gray_ref:=Value</l>
<c>    *求出检测的区域的面积</c>
<l>    area_center (regionsrc, AreaRegion, Row5, Column5)</l>
<c>    *抠出目标</c>
<l>*    deviation_value1:=50</l>
<l>    reduce_domain (imagesrc, regionsrc, ImageReduced)</l>
<c></c>
<l>    threshold (ImageReduced, Union, [0,gray_ref+deviation_value2], [gray_ref-deviation_value1,255])    </l>
<l>    union1 (Union, Union)</l>
<c>    *预处理</c>
<l>    closing_circle (Union, RegionClosing, 5.5)</l>
<l>    fill_up (RegionClosing, RegionFillUp)</l>
<l>    erosion_circle (RegionFillUp, RegionErosion, 5.5)</l>
<l>    dilation_circle (RegionErosion, RegionDilation, 5.5)</l>
<l>    connection (RegionDilation, ConnectedRegions)</l>
<l>    select_shape (ConnectedRegions, SelectedRegions, 'roundness', 'and', 0.8092, 2)</l>
<l>    count_obj (SelectedRegions, Number1)</l>
<l>    if(Number1 &lt;1)</l>
<l>        isError:=true</l>
<l>        ErrorCode:=1</l>
<c>        *返回1</c>
<l>        return ()</l>
<l>    endif</l>
<l>    select_obj (SelectedRegions, ObjectSelected1, 1)</l>
<l>    gen_contour_region_xld (ObjectSelected1, Contours, 'border')</l>
<l>    fit_circle_contour_xld (Contours, 'geotukey', -1, 2, 0, 10, 1, Row1, Column1, Radius, StartPhi, EndPhi, PointOrder)</l>
<l>    if(|Row1| != 1)</l>
<l>        isError:=true</l>
<l>        ErrorCode:=2</l>
<c>        *返回1</c>
<l>        return ()</l>
<l>    endif</l>
<l>    gen_circle_contour_xld (ContCircle, Row1, Column1, Radius, 0, 6.28318, 'positive', 1)</l>
<l>    dev_display (ContCircle)</l>
<l>    x1:=Column1</l>
<l>    y1:=Row1-Radius</l>
<l>    x2:=Column1</l>
<l>    y2:=Row1+Radius</l>
<l>    Length:=Radius*2*factor</l>
<l>    length := Length</l>
<l>    center_x := Column1</l>
<l>    center_y := Row1</l>
<l>    DrawIndica (x1, y1, x2, y2, 0, Radius*2.5, Length, WindowHandle, 1)</l>
<l>catch (Exception)</l>
<l>    dev_get_exception_data (Exception, 'error_msg', ErrorMsg)</l>
<l>    disp_message (WindowHandle, 'Error message: ' + ErrorMsg, 'window', 12, 12, 'red', 'true')</l>
<l>    isError:=true</l>
<l>    ErrorCode:=4</l>
<c>    *返回1</c>
<l>    return ()</l>
<l>endtry</l>
<l>return ()</l>
</body>
<docu id="SingleCircle">
<parameters>
<parameter id="ErrorCode"/>
<parameter id="WindowHandle"/>
<parameter id="center_x"/>
<parameter id="center_y"/>
<parameter id="deviation_value1"/>
<parameter id="deviation_value2"/>
<parameter id="factor"/>
<parameter id="imagesrc"/>
<parameter id="isError"/>
<parameter id="length"/>
<parameter id="regionref"/>
<parameter id="regionsrc"/>
</parameters>
</docu>
</procedure>
</hdevelop>
